## Spring Aop面向切面编程
底层：代理模式
1) 静态代理
2) 动态代理
    1）jdk动态代理
    2）cglib动态代理

通俗解释：在执行目标方法的前后通过代理模式执行公共的代码。比如打印日志，处理事务。
#### 静态代理模式实现
被代理类（目标类）OrderServiceImpl实现接口OrderService，代理类OrderServiceProxy完成功能扩展。
静态代理模式需要手动为需要被代理的类创建其对应的代理类，如果有很多类需要被代理，那么代码非常冗余。而动态代理可以程序自动识别需要被代理的类然后进行代理。
#### 动态代理模式实现
jdk与cglib区别:
1) jdk动态代理基于接口方式代理，代理类实现目标接口。
2) cglib动态代理基于继承方式代理，代理类继承了目标类。
3) jdk7之前，cglib动态代理的效率较高；jdk7之后，jdk动态代理进行了优化，其效率更高。
##### jdk动态代理（使用更多）
流程：
1) 创建被代理的接口和类
2) 实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理
3) 调用Proxy的静态方法，创建代理类并生成相应的代理对象
4) 主函数中代理类实现了目标接口，调用代理类下的方法时会进入到InvocationHandler实现类的invoke方法。
##### cglib动态代理
cglib动态代理基于asm实现自动创建代理类的.class字节码文件，其继承了目标类。
cglib只是封装了asm，简化了asm操作，大部分功能还是由asm提供。  
流程：
1) 添加cglib依赖（同时自动添加asm依赖）
2) 创建被代理的接口和类
3) 实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法
#### Aop核心话术
1) 连接点：该类中哪些方法需要被增强，这些方法就可以称作连接点
2) 切点：实际被增强的方法
3) 通知：方法前后增强功能的代码  
1）前置通知 2）后置通知 3）环绕通知 4）异常通知
4) 切面：应用通知的过程